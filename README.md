# Chapter 1: Getting started with C++
## Section 1.1: Hello World
This program prints Hello World! to the standard output stream:
```CPP
#include <iostream>
int main()
{
std::cout << "Hello World!" << std::endl;
}
```


## Section 1.2: Comments
A comment is a way to put arbitrary text inside source code without having the C++ compiler interpret it with any
functional meaning. Comments are used to give insight into the design or method of a program.
There are two types of comments in C++:
 * Single-Line Comments
The double forward-slash sequence // will mark all text until a newline as a comment:
```CPP
int main()
{
// This is a single-line comment.
int a; // this also is a single-line comment
int i; // this is another single-line comment
}
```

 * C-Style/Block Comments
The sequence /* is used to declare the start of the comment block and the sequence */ is used to declare the end
of comment. All text between the start and end sequences is interpreted as a comment, even if the text is
otherwise valid C++ syntax. These are sometimes called "C-style" comments, as this comment syntax is inherited
from C :
```CPP
int main()
{
/*
* This is a block comment.
*/
int a;
}
```

## Section 1.3: The standard C++ compilation process
Executable C++ program code is usually produced by a compiler.
A compiler is a program that translates code from a programming language into another form which is (more)
directly executable for a computer. Using a compiler to translate code is called compilation.
C++ inherits the form of its compilation process from its "parent" language, C. Below is a list showing the four major
steps of compilation in C++:
1. The C++ preprocessor copies the contents of any included header files into the source code file, generates
macro code, and replaces symbolic constants defined using #define with their values.
2. The expanded source code file produced by the C++ preprocessor is compiled into assembly language
appropriate for the platform.
3. The assembler code generated by the compiler is assembled into appropriate object code for the platform.
4. The object code file generated by the assembler is linked together with the object code files for any library
functions used to produce an executable file.
Note: some compiled code is linked together, but not to create a final program. Usually, this "linked" code
can also be packaged into a format that can be used by other programs. This "bundle of packaged, usable
code" is what C++ programmers refer to as a library.
Many C++ compilers may also merge or un-merge certain parts of the compilation process for ease or for additional
analysis. Many C++ programmers will use different tools, but all of the tools will generally follow this generalized
process when they are involved in the production of a program


## Section 1.4: Function
A function is a unit of code that represents a sequence of statements.
Functions can accept arguments or values and return a single value (or not). To use a function, a function call is
used on argument values and the use of the function call itself is replaced with its return value.
Every function has a type signature -- the types of its arguments and the type of its return type.
Functions are inspired by the concepts of the procedure and the mathematical function.
Note: C++ functions are essentially procedures and do not follow the exact definition or rules of
mathematical functions.

Functions are often meant to perform a specific task. and can be called from other parts of a program. A function
must be declared and defined before it is called elsewhere in a program.
Note: popular function definitions may be hidden in other included files (often for convenience and reuse
across many files). This is a common use of header files.

1. Function Declaration
A function declaration is declares the existence of a function with its name and type signature to the compiler.

The syntax is as the following:
    int add2(int i); // The function is of the type (int) -> (int)
In the example above, the int add2(int i) function declares the following to the compiler:
- The return type is int.
- The name of the function is add2.
- The number of arguments to the function is 1:
    - The first argument is of the type int.
    - The first argument will be referred to in the function's contents by the name i.

The argument name is optional; the declaration for the function could also be the following:
    int add2(int); // Omitting the function arguments' name is also permitted.
Per the one-definition rule, a function with a certain type signature can only be declared or defined once in an
entire C++ code base visible to the C++ compiler. In other words, functions with a specific type signature cannot be
re-defined -- they must only be defined once. Thus, the following is not valid C++:
    int add2(int i); // The compiler will note that add2 is a function (int) -> int
    int add2(int j); // As add2 already has a definition of (int) -> int, the compiler
    // will regard this as an error.
If a function returns nothing, its return type is written as void. If it takes no parameters, the parameter list should
be empty.

    void do_something(); // The function takes no parameters, and does not return anything.
// Note that it can still affect variables it has access to.

1. Function Call
A function can be called after it has been declared. For example, the following program calls add2 with the value of
2 within the function of main:
```CPP
#include <iostream>
int add2(int i); // Declaration of add2
// Note: add2 is still missing a DEFINITION.
// Even though it doesn't appear directly in code,
// add2's definition may be LINKED in from another object file.
int main()
{
std::cout << add2(2) << "\n"; // add2(2) will be evaluated at this point,
// and the result is printed.
return 0;
}
```
Here, add2(2) is the syntax for a function call.


1. Function Definition
A function definition* is similar to a declaration, except it also contains the code that is executed when the function
is called within its body.
An example of a function definition for add2 might be:
```CPP
int add2(int i) // Data that is passed into (int i) will be referred to by the name i
{ // while in the function's curly brackets or "scope."
int j = i + 2; // Definition of a variable j as the value of i+2.
return j; // Returning or, in essence, substitution of j for a function call to
// add2.
}
```

1. Function Overloading
You can create multiple functions with the same name but different parameters.
```CPP
int add2(int i) // Code contained in this definition will be evaluated
{ // when add2() is called with one parameter.
int j = i + 2;
return j;
}
int add2(int i, int j) // However, when add2() is called with two parameters, the
{ // code from the initial declaration will be overloaded,
int k = i + j + 2 ; // and the code in this declaration will be evaluated
return k; // instead.
}
```
Both functions are called by the same name add2, but the actual function that is called depends directly on the
amount and type of the parameters in the call. In most cases, the C++ compiler can compute which function to call.
In some cases, the type must be explicitly stated.

1. Default Parameters
Default values for function parameters can only be specified in function declarations.
```CPP
int multiply(int a, int b = 7); // b has default value of 7.
int multiply(int a, int b)
{
return a * b; // If multiply() is called with one parameter, the
} // value will be multiplied by the default, 7.
```
In this example, multiply() can be called with one or two parameters. If only one parameter is given, b will have
default value of 7. Default arguments must be placed in the latter arguments of the function. For example:
    int multiply(int a = 10, int b = 20); // This is legal
    int multiply(int a = 10, int b); // This is illegal since int a is in the former

1. Special Function Calls - Operators
There exist special function calls in C++ which have different syntax than name_of_function(value1, value2,
value3). The most common example is that of operators.

Certain special character sequences that will be reduced to function calls by the compiler, such as !, +, -
, *, %, and << and many more. These special characters are normally associated with non-programming usage or are
used for aesthetics (e.g. the + character is commonly recognized as the addition symbol both within C++
programming as well as in elementary math).
C++ handles these character sequences with a special syntax; but, in essence, each occurrence of an operator is
reduced to a function call. For example, the following C++ expression:
3+3
is equivalent to the following function call:
operator+(3, 3)
All operator function names start with operator.
While in C++'s immediate predecessor, C, operator function names cannot be assigned different meanings by
providing additional definitions with different type signatures, in C++, this is valid. "Hiding" additional function
definitions under one unique function name is referred to as operator overloading in C++, and is a relatively
common, but not universal, convention in C++.