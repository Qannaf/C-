# C++ notions de base
--------------------
<p align="center">
  <img width="250" height="210" src="C++.png">
</p>


# Chapter 1: Getting started with C++
## Section 1.1: Hello World
This program prints Hello World! to the standard output stream:
```CPP
#include <iostream>
int main()
{
std::cout << "Hello World!" << std::endl;
}
```

## Section 1.2: Comments
A comment is a way to put arbitrary text inside source code without having the C++ compiler interpret it with any
functional meaning. Comments are used to give insight into the design or method of a program.
There are two types of comments in C++:
 * Single-Line Comments
The double forward-slash sequence // will mark all text until a newline as a comment:
```CPP
int main()
{
// This is a single-line comment.
int a; // this also is a single-line comment
int i; // this is another single-line comment
}
```

 * C-Style/Block Comments
The sequence /* is used to declare the start of the comment block and the sequence */ is used to declare the end
of comment. All text between the start and end sequences is interpreted as a comment, even if the text is
otherwise valid C++ syntax. These are sometimes called "C-style" comments, as this comment syntax is inherited
from C :
```CPP
int main()
{
/*
* This is a block comment.
*/
int a;
}
```

## Section 1.3: The standard C++ compilation process
Executable C++ program code is usually produced by a compiler.
A compiler is a program that translates code from a programming language into another form which is (more)
directly executable for a computer. Using a compiler to translate code is called compilation.
C++ inherits the form of its compilation process from its "parent" language, C. Below is a list showing the four major
steps of compilation in C++:
1. The C++ preprocessor copies the contents of any included header files into the source code file, generates
macro code, and replaces symbolic constants defined using #define with their values.
2. The expanded source code file produced by the C++ preprocessor is compiled into assembly language
appropriate for the platform.
3. The assembler code generated by the compiler is assembled into appropriate object code for the platform.
4. The object code file generated by the assembler is linked together with the object code files for any library
functions used to produce an executable file.
Note: some compiled code is linked together, but not to create a final program. Usually, this "linked" code
can also be packaged into a format that can be used by other programs. This "bundle of packaged, usable
code" is what C++ programmers refer to as a library.
Many C++ compilers may also merge or un-merge certain parts of the compilation process for ease or for additional
analysis. Many C++ programmers will use different tools, but all of the tools will generally follow this generalized
process when they are involved in the production of a program


## Section 1.4: Function
A function is a unit of code that represents a sequence of statements.
Functions can accept arguments or values and return a single value (or not). To use a function, a function call is
used on argument values and the use of the function call itself is replaced with its return value.
Every function has a type signature -- the types of its arguments and the type of its return type.
Functions are inspired by the concepts of the procedure and the mathematical function.
Note: C++ functions are essentially procedures and do not follow the exact definition or rules of
mathematical functions.

Functions are often meant to perform a specific task. and can be called from other parts of a program. A function
must be declared and defined before it is called elsewhere in a program.
Note: popular function definitions may be hidden in other included files (often for convenience and reuse
across many files). This is a common use of header files.

1. Function Declaration
A function declaration is declares the existence of a function with its name and type signature to the compiler.

The syntax is as the following:
    int add2(int i); // The function is of the type (int) -> (int)
In the example above, the int add2(int i) function declares the following to the compiler:
- The return type is int.
- The name of the function is add2.
- The number of arguments to the function is 1:
    - The first argument is of the type int.
    - The first argument will be referred to in the function's contents by the name i.

The argument name is optional; the declaration for the function could also be the following:
    int add2(int); // Omitting the function arguments' name is also permitted.
Per the one-definition rule, a function with a certain type signature can only be declared or defined once in an
entire C++ code base visible to the C++ compiler. In other words, functions with a specific type signature cannot be
re-defined -- they must only be defined once. Thus, the following is not valid C++:
    int add2(int i); // The compiler will note that add2 is a function (int) -> int
    int add2(int j); // As add2 already has a definition of (int) -> int, the compiler
    // will regard this as an error.
If a function returns nothing, its return type is written as void. If it takes no parameters, the parameter list should
be empty.

    void do_something(); // The function takes no parameters, and does not return anything.
// Note that it can still affect variables it has access to.

2. Function Call
A function can be called after it has been declared. For example, the following program calls add2 with the value of
2 within the function of main:
```CPP
#include <iostream>
int add2(int i); // Declaration of add2
// Note: add2 is still missing a DEFINITION.
// Even though it doesn't appear directly in code,
// add2's definition may be LINKED in from another object file.
int main()
{
std::cout << add2(2) << "\n"; // add2(2) will be evaluated at this point,
// and the result is printed.
return 0;
}
```
Here, add2(2) is the syntax for a function call.


3. Function Definition
A function definition* is similar to a declaration, except it also contains the code that is executed when the function
is called within its body.
An example of a function definition for add2 might be:
```CPP
int add2(int i) // Data that is passed into (int i) will be referred to by the name i
{ // while in the function's curly brackets or "scope."
int j = i + 2; // Definition of a variable j as the value of i+2.
return j; // Returning or, in essence, substitution of j for a function call to
// add2.
}
```

1. Function Overloading
You can create multiple functions with the same name but different parameters.
```CPP
int add2(int i) // Code contained in this definition will be evaluated
{ // when add2() is called with one parameter.
int j = i + 2;
return j;
}
int add2(int i, int j) // However, when add2() is called with two parameters, the
{ // code from the initial declaration will be overloaded,
int k = i + j + 2 ; // and the code in this declaration will be evaluated
return k; // instead.
}
```
Both functions are called by the same name add2, but the actual function that is called depends directly on the
amount and type of the parameters in the call. In most cases, the C++ compiler can compute which function to call.
In some cases, the type must be explicitly stated.

4. Default Parameters
Default values for function parameters can only be specified in function declarations.
```CPP
int multiply(int a, int b = 7); // b has default value of 7.
int multiply(int a, int b)
{
return a * b; // If multiply() is called with one parameter, the
} // value will be multiplied by the default, 7.
```
In this example, multiply() can be called with one or two parameters. If only one parameter is given, b will have
default value of 7. Default arguments must be placed in the latter arguments of the function. For example:
    int multiply(int a = 10, int b = 20); // This is legal
    int multiply(int a = 10, int b); // This is illegal since int a is in the former

5. Special Function Calls - Operators
There exist special function calls in C++ which have different syntax than name_of_function(value1, value2,
value3). The most common example is that of operators.

Certain special character sequences that will be reduced to function calls by the compiler, such as !, +, -
, *, %, and << and many more. These special characters are normally associated with non-programming usage or are
used for aesthetics (e.g. the + character is commonly recognized as the addition symbol both within C++
programming as well as in elementary math).
C++ handles these character sequences with a special syntax; but, in essence, each occurrence of an operator is
reduced to a function call. For example, the following C++ expression:
3+3
is equivalent to the following function call:
operator+(3, 3)
All operator function names start with operator.
While in C++'s immediate predecessor, C, operator function names cannot be assigned different meanings by
providing additional definitions with different type signatures, in C++, this is valid. "Hiding" additional function
definitions under one unique function name is referred to as operator overloading in C++, and is a relatively
common, but not universal, convention in C++.



## Section 1.5: Visibility of function prototypes and declarations
In C++, code must be declared or defined before usage. For example, the following produces a compile time error:
```CPP
int main()
{
foo(2); // error: foo is called, but has not yet been declared
}
void foo(int x) // this later definition is not known in main
{
}
```
There are two ways to resolve this: putting either the definition or declaration of foo() before its usage in main().
Here is one example:
```CPP
void foo(int x) {} //Declare the foo function and body first
int main()
{
foo(2); // OK: foo is completely defined beforehand, so it can be called here.
}
```
However it is also possible to "forward-declare" the function by putting only a "prototype" declaration before its
usage and then defining the function body later:
void foo(int); // Prototype declaration of foo, seen by main
// Must specify return type, name, and argument list types
```CPP
int main()
{
foo(2); // OK: foo is known, called even though its body is not yet defined
}
void foo(int x) //Must match the prototype
{
// Define body of foo here
}
```
The prototype must specify the return type (void), the name of the function (foo), and the argument list variable
types (int), but the names of the arguments are NOT required.
One common way to integrate this into the organization of source files is to make a header file containing all of the
prototype declarations:
// foo.h
void foo(int); // prototype declaration
and then provide the full definition elsewhere:
// foo.cpp --> foo.o
#include "foo.h" // foo's prototype declaration is "hidden" in here
void foo(int x) { } // foo's body definition
and then, once compiled, link the corresponding object file foo.o into the compiled object file where it is used in
the linking phase, main.o:
// main.cpp --> main.o
#include "foo.h" // foo's prototype declaration is "hidden" in here
int main() { foo(2); } // foo is valid to call because its prototype declaration was beforehand.
// the prototype and body definitions of foo are linked through the object files
An “unresolved external symbol” error occurs when the function prototype and call exist, but the function body is
not defined. These can be trickier to resolve as the compiler won't report the error until the final linking stage, and
it doesn't know which line to jump to in the code to show the error.
Section 1.6: Preprocessor
The preprocessor is an important part of the compiler.
It edits the source code, cutting some bits out, changing others, and adding other things.
In source files, we can include preprocessor directives. These directives tells the preprocessor to perform specific
actions. A directive starts with a # on a new line. Example:
```CPP 
#define ZERO 0 
```
The first preprocessor directive you will meet is probably the
```CPP
#include <something>
```
directive. What it does is takes all of something and inserts it in your file where the directive was. The hello world
program starts with the line
```CPP
#include <iostream>
```
This line adds the functions and objects that let you use the standard input and output.
The C language, which also uses the preprocessor, does not have as many header files as the C++ language, but in
C++ you can use all the C header files.
The next important directive is probably the
```CPP
#define something something_else
```
directive. This tells the preprocessor that as it goes along the file, it should replace every occurrence of something
with something_else. It can also make things similar to functions, but that probably counts as advanced C++.
The something_else is not needed, but if you define something as nothing, then outside preprocessor directives, all
occurrences of something will vanish.
This actually is useful, because of the #if,#else and #ifdef directives. The format for these would be the following:
```CPP
#if something==true
//code
#else
//more code
#endif
#ifdef thing_that_you_want_to_know_if_is_defined
//code
#endif
```
These directives insert the code that is in the true bit, and deletes the false bits. this can be used to have bits of
code that are only included on certain operating systems, without having to rewrite the whole code.




# Chapter 2: Templates
Classes, functions, and (since C++14) variables can be templated. A template is a piece of code with some free
parameters that will become a concrete class, function, or variable when all parameters are specified. Parameters
can be types, values, or themselves templates. A well-known template is std::vector, which becomes a concrete
container type when the element type is specified, e.g., std::vector<int>.
## Section 2.1: Basic Class Template
The basic idea of a class template is that the template parameter gets substituted by a type at compile time. The
result is that the same class can be reused for multiple types. The user specifies which type will be used when a
variable of the class is declared. Three examples of this are shown in main():
```CPP
#include <iostream>
using std::cout;
template <typename T> // A simple class to hold one number of any type
class Number {
public:
void setNum(T n); // Sets the class field to the given number
T plus1() const; // returns class field's "follower"
private:
T num; // Class field
};
template <typename T> // Set the class field to the given number
void Number<T>::setNum(T n) {
num = n;
}
template <typename T> // returns class field's "follower"
T Number<T>::plus1() const {
return num + 1;
}

int main() {
Number<int> anInt; // Test with an integer (int replaces T in the class)
anInt.setNum(1);
cout << "My integer + 1 is " << anInt.plus1() << "\n"; // Prints 2
Number<double> aDouble; // Test with a double
aDouble.setNum(3.1415926535897);
cout << "My double + 1 is " << aDouble.plus1() << "\n"; // Prints 4.14159
Number<float> aFloat; // Test with a float
aFloat.setNum(1.4);
cout << "My float + 1 is " << aFloat.plus1() << "\n"; // Prints 2.4
return 0; // Successful completion
}
```

## Section 2.2: Function Templates
Templating can also be applied to functions (as well as the more traditional structures) with the same effect.
// 'T' stands for the unknown type
// Both of our arguments will be of the same type.
```CPP
template<typename T>
void printSum(T add1, T add2)
{
std::cout << (add1 + add2) << std::endl;
}
```
This can then be used in the same way as structure templates.
```CPP
printSum<int>(4, 5);
printSum<float>(4.5f, 8.9f);
```
In both these case the template argument is used to replace the types of the parameters; the result works just like
a normal C++ function (if the parameters don't match the template type the compiler applies the standard
conversions).
One additional property of template functions (unlike template classes) is that the compiler can infer the template
parameters based on the parameters passed to the function.
```CPP
printSum(4, 5); // Both parameters are int.
// This allows the compiler deduce that the type
// T is also int.
printSum(5.0, 4); // In this case the parameters are two different types.
// The compiler is unable to deduce the type of T
// because there are contradictions. As a result
// this is a compile time error.
```
This feature allows us to simplify code when we combine template structures and functions. There is a common
pattern in the standard library that allows us to make template structure X using a helper function make_X().
```CPP
// The make_X pattern looks like this.
// 1) A template structure with 1 or more template types.
template<typename T1, typename T2>
struct MyPair
{
T1 first;
T2 second;
};
// 2) A make function that has a parameter type for
// each template parameter in the template structure.
template<typename T1, typename T2>
MyPair<T1, T2> make_MyPair(T1 t1, T2 t2)
{
return MyPair<T1, T2>{t1, t2};
}
How does this help?
auto val1 = MyPair<int, float>{5, 8.7}; // Create object explicitly defining the types
auto val2 = make_MyPair(5, 8.7); // Create object using the types of the paramters.
// In this code both val1 and val2 are the same
// type.
```
Note: This is not designed to shorten the code. This is designed to make the code more robust. It allows the types
to be changed by changing the code in a single place rather than in multiple locations.

## Section 2.3: Variadic template data structures
Version ≥ C++14
It is often useful to define classes or structures that have a variable number and type of data members which are
defined at compile time. The canonical example is std::tuple, but sometimes is it is necessary to define your own
custom structures. Here is an example that defines the structure using compounding (rather than inheritance as
with std::tuple. Start with the general (empty) definition, which also serves as the base-case for recrusion
termination in the later specialisation:
```CPP
template<typename ... T>
struct DataStructure {};
```
This already allows us to define an empty structure, DataStructure<> data, albeit that isn't very useful yet.
Next comes the recursive case specialisation:
```CPP
template<typename T, typename ... Rest>
struct DataStructure<T, Rest ...>
{
DataStructure(const T& first, const Rest& ... rest)
: first(first)
, rest(rest...)
{}
T first;
DataStructure<Rest ... > rest;
};
```
This is now sufficient for us to create arbitrary data structures, like DataStructure<int, float, std::string>
data(1, 2.1, "hello").
So what's going on? First, note that this is a specialisation whose requirement is that at least one variadic template
parameter (namely T above) exists, whilst not caring about the specific makeup of the pack Rest. Knowing that T
exists allows the definition of its data member, first. The rest of the data is recursively packaged as
DataStructure<Rest ... > rest. The constructor initiates both of those members, including a recursive
constructor call to the rest member.
To understand this better, we can work through an example: suppose you have a declaration DataStructure<int,
float> data. The declaration first matches against the specialisation, yielding a structure with int first and
DataStructure<float> rest data members. The rest definition again matches this specialisation, creating its own
float first and DataStructure<> rest members. Finally this last rest matches against the base-case defintion,
producing an empty structure.
You can visualise this as follows:
DataStructure<int, float>
-> int first
-> DataStructure<float> rest
-> float first
-> DataStructure<> rest
-> (empty)
Now we have the data structure, but its not terribly useful yet as we cannot easily access the individual data
elements (for example to access the last member of DataStructure<int, float, std::string> data we would
have to use data.rest.rest.first, which is not exactly user-friendly). So we add a get method to it (only needed
C++ Notes for Professionals 14
in the specialisation as the base-case structure has no data to get):
```CPP
template<typename T, typename ... Rest>
struct DataStructure<T, Rest ...>
{
...
template<size_t idx>
auto get()
{
return GetHelper<idx, DataStructure<T,Rest...>>::get(*this);
}
...
};
```
As you can see this get member function is itself templated - this time on the index of the member that is needed
(so usage can be things like data.get<1>(), similar to std::tuple). The actual work is done by a static function in a
helper class, GetHelper. The reason we can't define the required functionality directly in DataStructure's get is
because (as we will shortly see) we would need to specialise on idx - but it isn't possible to specialise a template
member function without specialising the containing class template. Note also the use of a C++14-style auto here
makes our lives significantly simpler as otherwise we would need quite a complicated expression for the return
type.
So on to the helper class. This time we will need an empty forward declaration and two specialisations. First the
declaration:
```CPP
template<size_t idx, typename T>
struct GetHelper;
Now the base-case (when idx==0). In this case we just return the first member:
template<typename T, typename ... Rest>
struct GetHelper<0, DataStructure<T, Rest ... >>
{
static T get(DataStructure<T, Rest...>& data)
{
return data.first;
}
};
```
In the recursive case, we decrement idx and invoke the GetHelper for the rest member:
```CPP
template<size_t idx, typename T, typename ... Rest>
struct GetHelper<idx, DataStructure<T, Rest ... >>
{
static auto get(DataStructure<T, Rest...>& data)
{
return GetHelper<idx-1, DataStructure<Rest ...>>::get(data.rest);
}
};
```
To work through an example, suppose we have DataStructure<int, float> data and we need data.get<1>().
This invokes GetHelper<1, DataStructure<int, float>>::get(data) (the 2nd specialisation), which in turn
invokes GetHelper<0, DataStructure<float>>::get(data.rest), which finally returns (by the 1st specialisation as
now idx is 0) data.rest.first.
So that's it! Here is the whole functioning code, with some example use in the main function:
```CPP
#include <iostream>
template<size_t idx, typename T>
struct GetHelper;
template<typename ... T>
struct DataStructure
{
};
template<typename T, typename ... Rest>
struct DataStructure<T, Rest ...>
{
DataStructure(const T& first, const Rest& ... rest)
: first(first)
, rest(rest...)
{}
T first;
DataStructure<Rest ... > rest;
template<size_t idx>
auto get()
{
return GetHelper<idx, DataStructure<T,Rest...>>::get(*this);
}
};
template<typename T, typename ... Rest>
struct GetHelper<0, DataStructure<T, Rest ... >>
{
static T get(DataStructure<T, Rest...>& data)
{
return data.first;
}
};
template<size_t idx, typename T, typename ... Rest>
struct GetHelper<idx, DataStructure<T, Rest ... >>
{
static auto get(DataStructure<T, Rest...>& data)
{
return GetHelper<idx-1, DataStructure<Rest ...>>::get(data.rest);
}
};
int main()
{
DataStructure<int, float, std::string> data(1, 2.1, "Hello");
std::cout << data.get<0>() << std::endl;
std::cout << data.get<1>() << std::endl;
std::cout << data.get<2>() << std::endl;
return 0;
}
```

## Section 2.4: Argument forwarding
Template may accept both lvalue and rvalue references using forwarding reference:
```CPP
template <typename T>
void f(T &&t);
In this case, the real type of t will be deduced depending on the context:
struct X { };
X x;
f(x); // calls f<X&>(x)
f(X()); // calls f<X>(x)
```
In the first case, the type T is deduced as reference to X (X&), and the type of t is lvalue reference to X, while in the
second case the type of T is deduced as X and the type of t as rvalue reference to X (X&&).
Note: It is worth noticing that in the first case, decltype(t) is the same as T, but not in the second.
In order to perfectly forward t to another function ,whether it is an lvalue or rvalue reference, one must use
std::forward:
```CPP
template <typename T>
void f(T &&t) {
g(std::forward<T>(t));
}
Forwarding references may be used with variadic templates:
template <typename... Args>
void f(Args&&... args) {
g(std::forward<Args>(args)...);
}
```
Note: Forwarding references can only be used for template parameters, for instance, in the following code, v is a
rvalue reference, not a forwarding reference:
```CPP
#include <vector>
template <typename T>
void f(std::vector<T> &&v);
```

## Section 2.5: Partial template specialization
In contrast of a full template specialization partial template specialization allows to introduce template with some of
the arguments of existing template fixed. Partial template specialization is only available for template class/structs:
```CPP
// Common case:
template<typename T, typename U>
struct S {
T t_val;
U u_val;
};
// Special case when the first template argument is fixed to int
template<typename V>
struct S<int, V> {
double another_value;
int foo(double arg) {// Do something}
};
```
As shown above, partial template specializations may introduce completely different sets of data and function
members.
When a partially specialized template is instantiated, the most suitable specialization is selected. For example, let's
define a template and two partial specializations:
```CPP
template<typename T, typename U, typename V>
struct S {
static void foo() {
std::cout << "General case\n";
}
};
template<typename U, typename V>
struct S<int, U, V> {
static void foo() {
std::cout << "T = int\n";
}
};
template<typename V>
struct S<int, double, V> {
static void foo() {
std::cout << "T = int, U = double\n";
}
};
```
Now the following calls:
```CPP
S<std::string, int, double>::foo();
S<int, float, std::string>::foo();
S<int, double, std::string>::foo();
```
will print
General case
```CPP
T = int
T = int, U = double
```
Function templates may only be fully specialized:
```CPP
template<typename T, typename U>
void foo(T t, U u) {
std::cout << "General case: " << t << " " << u << std::endl;
}
// OK.
template<>
void foo<int, int>(int a1, int a2) {
std::cout << "Two ints: " << a1 << " " << a2 << std::endl;
}
void invoke_foo() {
foo(1, 2.1); // Prints "General case: 1 2.1"
foo(1,2); // Prints "Two ints: 1 2"
}

// Compilation error: partial function specialization is not allowed.
template<typename U>
void foo<std::string, U>(std::string t, U u) {
std::cout << "General case: " << t << " " << u << std::endl;
}
```

## Section 2.6: Template Specialization
You can define implementation for specific instantiations of a template class/method.
For example if you have:
```CPP
template <typename T>
T sqrt(T t) { /* Some generic implementation */ }
```
You can then write:
```CPP
template<>
int sqrt<int>(int i) { /* Highly optimized integer implementation */ }
```
Then a user that writes sqrt(4.0) will get the generic implementation whereas sqrt(4) will get the specialized
implementation.

## Section 2.7: Alias template
Version ≥ C++11
Basic example:
```CPP
template<typename T> using pointer = T*;
```
This definition makes pointer<T> an alias of T*. For example:
```CPP
pointer<int> p = new int; // equivalent to: int* p = new int;
```
Alias templates cannot be specialized. However, that functionality can be obtained indirectly by having them refer
to a nested type in a struct:
```CPP
template<typename T>
struct nonconst_pointer_helper { typedef T* type; };
template<typename T>
struct nonconst_pointer_helper<T const> { typedef T* type; };
template<typename T> using nonconst_pointer = nonconst_pointer_helper<T>::type;
```

## Section 2.8: Explicit instantiation
An explicit instantiation definition creates and declares a concrete class, function, or variable from a template,
without using it just yet. An explicit instantiation can be referenced from other translation units. This can be used to
avoid defining a template in a header file, if it will only be instantiated with a finite set of arguments. For example:
```CPP
// print_string.h
template <class T>
void print_string(const T* str);
// print_string.cpp
#include "print_string.h"
template void print_string(const char*);
template void print_string(const wchar_t*);
```
Because print_string<char> and print_string<wchar_t> are explicitly instantiated in print_string.cpp, the
linker will be able to find them even though the print_string template is not defined in the header. If these explicit
instantiation declarations were not present, a linker error would likely occur. See Why can templates only be
implemented in the header file?
Version ≥ C++11
If an explicit instantiation definition is preceded by the extern keyword, it becomes an explicit instantiation
declaration instead. The presence of an explicit instantiation declaration for a given specialization prevents the
implicit instantiation of the given specialization within the current translation unit. Instead, a reference to that
specialization that would otherwise cause an implicit instantiation can refer to an explicit instantiation definition in
the same or another TU.
foo.h
```CPP
#ifndef FOO_H
#define FOO_H
template <class T> void foo(T x) {
// complicated implementation
}
#endif
```
foo.cpp
```CPP
#include "foo.h"
// explicit instantiation definitions for common cases
template void foo(int);
template void foo(double);
```
main.cpp
```CPP
#include "foo.h"
// we already know foo.cpp has explicit instantiation definitions for these
extern template void foo(double);
int main() {
foo(42); // instantiates foo<int> here;
// wasteful since foo.cpp provides an explicit instantiation already!
foo(3.14); // does not instantiate foo<double> here;
// uses instantiation of foo<double> in foo.cpp instead
}
```

## Section 2.9: Non-type template parameter
Apart from types as a template parameter we are allowed to declare values of constant expressions meeting one of
the following criteria:
integral or enumeration type,
pointer to object or pointer to function,
lvalue reference to object or lvalue reference to function,
pointer to member,
std::nullptr_t.
Like all template parameters, non-type template parameters can be explicitly specified, defaulted, or derived
implicitly via Template Argument Deduction.
Example of non-type template parameter usage:
```CPP
#include <iostream>
template<typename T, std::size_t size>
std::size_t size_of(T (&anArray)[size]) // Pass array by reference. Requires.
{ // an exact size. We allow all sizes
return size; // by using a template "size".
}
int main()
{
char anArrayOfChar[15];
std::cout << "anArrayOfChar: " << size_of(anArrayOfChar) << "\n";
int anArrayOfData[] = {1,2,3,4,5,6,7,8,9};
std::cout << "anArrayOfData: " << size_of(anArrayOfData) << "\n";
}
```
Example of explicitly specifying both type and non-type template parameters:
```CPP
#include <array>
int main ()
{
std::array<int, 5> foo; // int is a type parameter, 5 is non-type
}
```
Non-type template parameters are one of the ways to achieve template recurrence and enables to do
Metaprogramming.

## Section 2.10: Declaring non-type template arguments with auto
Prior to C++17, when writing a template non-type parameter, you had to specify its type first. So a common pattern
became writing something like:
```CPP
template <class T, T N>
struct integral_constant {
using type = T;
static constexpr T value = N;
};
using five = integral_constant<int, 5>;
```
But for complicated expressions, using something like this involves having to write decltype(expr), expr when
instantiating templates. The solution is to simplify this idiom and simply allow auto:
Version ≥ C++17
```CPP
template <auto N>
struct integral_constant {
using type = decltype(N);
static constexpr type value = N;
};
C++ Notes for Professionals 21
using five = integral_constant<5>;
```
Empty custom deleter for unique_ptr
A nice motivating example can come from trying to combine the empty base optimization with a custom deleter for
unique_ptr. Different C API deleters have different return types, but we don't care - we just want something to
work for any function:
```CPP
template <auto DeleteFn>
struct FunctionDeleter {
template <class T>
void operator()(T* ptr) const {
DeleteFn(ptr);
}
};
template <T, auto DeleteFn>
using unique_ptr_deleter = std::unique_ptr<T, FunctionDeleter<DeleteFn>>;
```
And now you can simply use any function pointer that can take an argument of type T as a template non-type
parameter, regardless of return type, and get a no-size overhead unique_ptr out of it:
```CPP
unique_ptr_deleter<std::FILE, std::fclose> p;
```

## Section 2.11: Template template parameters
Sometimes we would like to pass into the template a template type without fixing its values. This is what template
template parameters are created for. Very simple template template parameter examples:
```CPP
template <class T>
struct Tag1 { };
template <class T>
struct Tag2 { };
template <template <class> class Tag>
struct IntTag {
typedef Tag<int> type;
};
int main() {
IntTag<Tag1>::type t;
}
```
Version ≥ C++11
```CPP
#include <vector>
#include <iostream>
template <class T, template <class...> class C, class U>
C<T> cast_all(const C<U> &c) {
C<T> result(c.begin(), c.end());
return result;
}
int main() {
std::vector<float> vf = {1.2, 2.6, 3.7};
auto vi = cast_all<int>(vf);
for(auto &&i: vi) {
std::cout << i << std::endl;
}
}
```

## Section 2.12: Default template parameter value
Just like in case of the function arguments, template parameters can have their default values. All template
parameters with a default value have to be declared at the end of the template parameter list. The basic idea is that
the template parameters with default value can be omitted while template instantiation.
Simple example of default template parameter value usage:
```CPP
template <class T, size_t N = 10>
struct my_array {
T arr[N];
};
int main() {
/* Default parameter is ignored, N = 5 */
my_array<int, 5> a;
/* Print the length of a.arr: 5 */
std::cout << sizeof(a.arr) / sizeof(int) << std::endl;
/* Last parameter is omitted, N = 10 */
my_array<int> b;
/* Print the length of a.arr: 10 */
std::cout << sizeof(b.arr) / sizeof(int) << std::endl;
}
```



# Chapter 3: Metaprogramming
In C++ Metaprogramming refers to the use of macros or templates to generate code at compile-time.
In general, macros are frowned upon in this role and templates are preferred, although they are not as generic.
Template metaprogramming often makes use of compile-time computations, whether via templates or constexpr
functions, to achieve its goals of generating code, however compile-time computations are not metaprogramming
per se.
## Section 3.1: Calculating Factorials
Factorials can be computed at compile-time using template metaprogramming techniques.
```CPP
#include <iostream>
template<unsigned int n>
struct factorial
{
enum
{
value = n * factorial<n - 1>::value
};
};
template<>
struct factorial<0>
{
enum { value = 1 };
};
int main()
{
std::cout << factorial<7>::value << std::endl; // prints "5040"
}
```
factorial is a struct, but in template metaprogramming it is treated as a template metafunction. By convention,
template metafunctions are evaluated by checking a particular member, either ::type for metafunctions that result
in types, or ::value for metafunctions that generate values.
In the above code, we evaluate the factorial metafunction by instantiating the template with the parameters we
want to pass, and using ::value to get the result of the evaluation.
The metafunction itself relies on recursively instantiating the same metafunction with smaller values. The
factorial<0> specialization represents the terminating condition. Template metaprogramming has most of the
restrictions of a functional programming language, so recursion is the primary "looping" construct.
Since template metafunctions execute at compile time, their results can be used in contexts that require compiletime
values. For example:
int my_array[factorial<5>::value];
Automatic arrays must have a compile-time defined size. And the result of a metafunction is a compile-time
constant, so it can be used here.
Limitation: Most of the compilers won't allow recursion depth beyond a limit. For example, g++ compiler by default
C++ Notes for Professionals 24
limits recursion depeth to 256 levels. In case of g++, programmer can set recursion depth using -ftemplate-depth-
X option.
Version ≥ C++11
Since C++11, the std::integral_constant template can be used for this kind of template computation:
```CPP
#include <iostream>
#include <type_traits>
template<long long n>
struct factorial :
std::integral_constant<long long, n * factorial<n - 1>::value> {};
template<>
struct factorial<0> :
std::integral_constant<long long, 1> {};
int main()
{
std::cout << factorial<7>::value << std::endl; // prints "5040"
}
Additionally, constexpr functions become a cleaner alternative.
#include <iostream>
constexpr long long factorial(long long n)
{
return (n == 0) ? 1 : n * factorial(n - 1);
}
int main()
{
char test[factorial(3)];
std::cout << factorial(7) << '\n';
}
```
The body of factorial() is written as a single statement because in C++11 constexpr functions can only use a
quite limited subset of the language.
Version ≥ C++14
Since C++14, many restrictions for constexpr functions have been dropped and they can now be written much
more conveniently:
```CPP
constexpr long long factorial(long long n)
{
if (n == 0)
return 1;
else
return n * factorial(n - 1);
}
```
Or even:
```CPP
constexpr long long factorial(int n)
{
long long result = 1;

for (int i = 1; i <= n; ++i) {
result *= i;
}
return result;
}
```
Version ≥ C++17
Since c++17 one can use fold expression to calculate factorial:
```CPP
#include <iostream>
#include <utility>
template <class T, T N, class I = std::make_integer_sequence<T, N>>
struct factorial;
template <class T, T N, T... Is>
struct factorial<T,N,std::index_sequence<T, Is...>> {
static constexpr T value = (static_cast<T>(1) * ... * (Is + 1));
};
int main() {
std::cout << factorial<int, 5>::value << std::endl;
}
```
Section 3.2: Iterating over a parameter pack
Often, we need to perform an operation over every element in a variadic template parameter pack. There are many
ways to do this, and the solutions get easier to read and write with C++17. Suppose we simply want to print every
element in a pack. The simplest solution is to recurse:
Version ≥ C++11
void print_all(std::ostream& os) {
// base case
}
```CPP
template <class T, class... Ts>
void print_all(std::ostream& os, T const& first, Ts const&... rest) {
os << first;
print_all(os, rest...);
}
```
We could instead use the expander trick, to perform all the streaming in a single function. This has the advantage of
not needing a second overload, but has the disadvantage of less than stellar readability:
Version ≥ C++11
```CPP
template <class... Ts>
void print_all(std::ostream& os, Ts const&... args) {
using expander = int[];
(void)expander{0,
(void(os << args), 0)...
};
}
```
For an explanation of how this works, see T.C's excellent answer.
Version ≥ C++17
With C++17, we get two powerful new tools in our arsenal for solving this problem. The first is a fold-expression:
C++ Notes for Professionals 26
```CPP
template <class... Ts>
void print_all(std::ostream& os, Ts const&... args) {
((os << args), ...);
}
```
And the second is if constexpr, which allows us to write our original recursive solution in a single function:
```CPP
template <class T, class... Ts>
void print_all(std::ostream& os, T const& first, Ts const&... rest) {
os << first;
if constexpr (sizeof...(rest) > 0) {
// this line will only be instantiated if there are further
// arguments. if rest... is empty, there will be no call to
// print_all(os).
print_all(os, rest...);
}
}
```

## Section 3.3: Iterating with std::integer_sequence
Since C++14, the standard provides the class template
```CPP
template <class T, T... Ints>
class integer_sequence;
template <std::size_t... Ints>
using index_sequence = std::integer_sequence<std::size_t, Ints...>;
```
and a generating metafunction for it:
```CPP
template <class T, T N>
using make_integer_sequence = std::integer_sequence<T, /* a sequence 0, 1, 2, ..., N-1 */ >;
template<std::size_t N>
using make_index_sequence = make_integer_sequence<std::size_t, N>;
```
While this comes standard in C++14, this can be implemented using C++11 tools.
We can use this tool to call a function with a std::tuple of arguments (standardized in C++17 as std::apply):
```CPP
namespace detail {
template <class F, class Tuple, std::size_t... Is>
decltype(auto) apply_impl(F&& f, Tuple&& tpl, std::index_sequence<Is...> ) {
return std::forward<F>(f)(std::get<Is>(std::forward<Tuple>(tpl))...);
}
}
template <class F, class Tuple>
decltype(auto) apply(F&& f, Tuple&& tpl) {
return detail::apply_impl(std::forward<F>(f),
std::forward<Tuple>(tpl),
std::make_index_sequence<std::tuple_size<std::decay_t<Tuple>>::value>{});
}
// this will print 3
int f(int, char, double);
auto some_args = std::make_tuple(42, 'x', 3.14);
int r = apply(f, some_args); // calls f(42, 'x', 3.14)
```

## Section 3.4: Tag Dispatching
A simple way of selecting between functions at compile time is to dispatch a function to an overloaded pair of
functions that take a tag as one (usually the last) argument. For example, to implement std::advance(), we can
dispatch on the iterator category:
```CPP
namespace details {
template <class RAIter, class Distance>
void advance(RAIter& it, Distance n, std::random_access_iterator_tag) {
it += n;
}
template <class BidirIter, class Distance>
void advance(BidirIter& it, Distance n, std::bidirectional_iterator_tag) {
if (n > 0) {
while (n--) ++it;
}
else {
while (n++) --it;
}
}
template <class InputIter, class Distance>
void advance(InputIter& it, Distance n, std::input_iterator_tag) {
while (n--) {
++it;
}
}
}
template <class Iter, class Distance>
void advance(Iter& it, Distance n) {
details::advance(it, n,
typename std::iterator_traits<Iter>::iterator_category{} );
}
```
The std::XY_iterator_tag arguments of the overloaded details::advance functions are unused function
parameters. The actual implementation does not matter (actually it is completely empty). Their only purpose is to
allow the compiler to select an overload based on which tag class details::advance is called with.
In this example, advance uses the iterator_traits<T>::iterator_category metafunction which returns one of
the iterator_tag classes, depending on the actual type of Iter. A default-constructed object of the
iterator_category<Iter>::type then lets the compiler select one of the different overloads of details::advance.
(This function parameter is likely to be completely optimized away, as it is a default-constructed object of an empty
struct and never used.)
Tag dispatching can give you code that's much easier to read than the equivalents using SFINAE and enable_if.
Note: while C++17's if constexpr may simplify the implementation of advance in particular, it is not suitable for open
implementations unlike tag dispatching.
Section 3.5: Detect Whether Expression is Valid
It is possible to detect whether an operator or function can be called on a type. To test if a class has an overload of
std::hash, one can do this:
```CPP
#include <functional> // for std::hash
#include <type_traits> // for std::false_type and std::true_type
#include <utility> // for std::declval
template<class, class = void>
struct has_hash
: std::false_type
{};
template<class T>
struct has_hash<T, decltype(std::hash<T>()(std::declval<T>()), void())>
: std::true_type
{};
```
Version ≥ C++17
Since C++17, std::void_t can be used to simplify this type of construct
```CPP
#include <functional> // for std::hash
#include <type_traits> // for std::false_type, std::true_type, std::void_t
#include <utility> // for std::declval
template<class, class = std::void_t<> >
struct has_hash
: std::false_type
{};
template<class T>
struct has_hash<T, std::void_t< decltype(std::hash<T>()(std::declval<T>())) > >
: std::true_type
{};
```
where std::void_t is defined as:
```CPP
template< class... > using void_t = void;
```
For detecting if an operator, such as operator< is defined, the syntax is almost the same:
```CPP
template<class, class = void>
struct has_less_than
: std::false_type
{};
template<class T>
struct has_less_than<T, decltype(std::declval<T>() < std::declval<T>(), void())>
: std::true_type
{};
```
These can be used to use a std::unordered_map<T> if T has an overload for std::hash, but otherwise attempt to
use a std::map<T>:
```CPP
template <class K, class V>
using hash_invariant_map = std::conditional_t<
has_hash<K>::value,
std::unordered_map<K, V>,
std::map<K,V>>;
```

## Section 3.6: If-then-else
Version ≥ C++11
The type std::conditional in the standard library header <type_traits> can select one type or the other, based
on a compile-time boolean value:
```CPP
template<typename T>
struct ValueOrPointer
{
typename std::conditional<(sizeof(T) > sizeof(void*)), T*, T>::type vop;
};
```
This struct contains a pointer to T if T is larger than the size of a pointer, or T itself if it is smaller or equal to a
pointer's size. Therefore sizeof(ValueOrPointer) will always be <= sizeof(void*).

## Section 3.7: Manual distinction of types when given any type T
When implementing SFINAE using std::enable_if, it is often useful to have access to helper templates that
determines if a given type T matches a set of criteria.
To help us with that, the standard already provides two types analog to true and false which are std::true_type
and std::false_type.
The following example show how to detect if a type T is a pointer or not, the is_pointer template mimic the
behavior of the standard std::is_pointer helper:
```CPP
template <typename T>
struct is_pointer_: std::false_type {};
template <typename T>
struct is_pointer_<T*>: std::true_type {};
template <typename T>
struct is_pointer: is_pointer_<typename std::remove_cv<T>::type> { }
```
There are three steps in the above code (sometimes you only need two):
1. The first declaration of is_pointer_ is the default case, and inherits from std::false_type. The default case
should always inherit from std::false_type since it is analogous to a "false condition".
2. The second declaration specialize the is_pointer_ template for pointer T* without caring about what T is
really. This version inherits from std::true_type.
3. The third declaration (the real one) simply remove any unnecessary information from T (in this case we
remove const and volatile qualifiers) and then fall backs to one of the two previous declarations.
Since 
```CPP
is_pointer<T> 
```
is a class, to access its value you need to either:
Use ::value, e.g. 
```CPP 
is_pointer<int>::value 
```
– value is a static class member of type bool inherited from
std::true_type or std::false_type;
Construct an object of this type, e.g. 
```CPP
is_pointer<int>{} 
```
– This works because std::is_pointer inherits its

default constructor from 
```CPP 
std::true_type
``` 
or 
```CPP
std::false_type 
```
(which have constexpr constructors) and both
std::true_type and std::false_type have constexpr conversion operators to bool.
It is a good habit to provides "helper helper templates" that let you directly access the value:
```CPP
template <typename T>
constexpr bool is_pointer_v = is_pointer<T>::value;
```
Version ≥ C++17
In C++17 and above, most helper templates already provide a _v version, e.g.:
```CPP
template< class T > constexpr bool is_pointer_v = is_pointer<T>::value;
template< class T > constexpr bool is_reference_v = is_reference<T>::value;
```

## Section 3.8: Calculating power with C++11 (and higher)
With C++11 and higher calculations at compile time can be much easier. For example calculating the power of a
given number at compile time will be following:
```CPP
template <typename T>
constexpr T calculatePower(T value, unsigned power) {
return power == 0 ? 1 : value * calculatePower(value, power-1);
}
```
Keyword constexpr is responsible for calculating function in compilation time, then and only then, when all the
requirements for this will be met (see more at constexpr keyword reference) for example all the arguments must
be known at compile time.
Note: In C++11 constexpr function must compose only from one return statement.
Advantages: Comparing this to the standard way of compile time calculation, this method is also useful for runtime
calculations. It means, that if the arguments of the function are not known at the compilation time (e.g. value and
power are given as input via user), then function is run in a compilation time, so there's no need to duplicate a code
(as we would be forced in older standards of C++).
E.g.
```CPP
void useExample() {
constexpr int compileTimeCalculated = calculatePower(3, 3); // computes at compile time,
// as both arguments are known at compilation time
// and used for a constant expression.
int value;
std::cin >> value;
int runtimeCalculated = calculatePower(value, 3); // runtime calculated,
// because value is known only at runtime.
}
```
Version ≥ C++17
Another way to calculate power at compile time can make use of fold expression as follows:
```CPP
#include <iostream>
#include <utility>
template <class T, T V, T N, class I = std::make_integer_sequence<T, N>>
struct power;
template <class T, T V, T N, T... Is>
```

# Chapter 4: Iterators
## Section 4.1: Overview
1. Iterators are Positions
Iterators are a means of navigating and operating on a sequence of elements and are a generalized extension of
pointers. Conceptually it is important to remember that iterators are positions, not elements. For example, take the
following sequence:
A B C
The sequence contains three elements and four positions
```cpp
    +---+---+---+---+
    | A | B | C |   |
    +---+---+---+---+
```
Elements are things within a sequence. Positions are places where meaningful operations can happen to the
sequence. For example, one inserts into a position, before or after element A, not into an element. Even deletion of
an element (erase(A)) is done by first finding its position, then deleting it.

2. From Iterators to Values
To convert from a position to a value, an iterator is dereferenced:
auto my_iterator = my_vector.begin(); // position
auto my_value = *my_iterator; // value
One can think of an iterator as dereferencing to the value it refers to in the sequence. This is especially useful in
understanding why you should never dereference the end() iterator in a sequence:
```cpp
    +---+---+---+---+
    | A | B | C |   |
    +---+---+---+---+
     ?            ?
     |            +-- An iterator here has no value. Do not dereference it!
     +-------------- An iterator here dereferences to the value A.
```
In all the sequences and containers found in the C++ standard library, begin() will return an iterator to the first
position, and end() will return an iterator to one past the last position (not the last position!). Consequently, the
names of these iterators in algorithms are oftentimes labelled first and last:
```cpp
+---+---+---+---+
| A | B | C |   |
+---+---+---+---+
 ?            ?
 |            |
 +- first     +- last
```
It is also possible to obtain an iterator to any sequence, because even an empty sequence contains at least one
C++ Notes for Professionals 33
position:
```cpp
    +---+
    |   |
    +---+
```
In an empty sequence, begin() and end() will be the same position, and neither can be dereferenced:
```cpp
    +---+
    |   |
    +---+
     ?
     |
     +- empty_sequence.begin()
     |
     +- empty_sequence.end()
```
The alternative visualization of iterators is that they mark the positions between elements:
```cpp
    +---+---+---+
    | A | B | C |
    +---+---+---+
    ?   ^   ^   ?
    |           |
    +- first    +- last
```
and dereferencing an iterator returns a reference to the element coming after the iterator. Some situations where
this view is particularly useful are:
insert operations will insert elements into the position indicated by the iterator,
erase operations will return an iterator corresponding to the same position as the one passed in,
an iterator and its corresponding reverse iterator are located in the same .position between elements

3. Invalid Iterators
An iterator becomes invalidated if (say, in the course of an operation) its position is no longer a part of a sequence.
An invalidated iterator cannot be dereferenced until it has been reassigned to a valid position. For example:
```CPP
std::vector<int>::iterator first;
{
std::vector<int> foo;
first = foo.begin(); // first is now valid
} // foo falls out of scope and is destroyed
// At this point first is now invalid
```
The many algorithms and sequence member functions in the C++ standard library have rules governing when
iterators are invalidated. Each algorithm is different in the way they treat (and invalidate) iterators.
Navigating with Iterators
As we know, iterators are for navigating sequences. In order to do that an iterator must migrate its position
throughout the sequence. Iterators can advance forward in the sequence and some can advance backwards:
```CPP
auto first = my_vector.begin();
++first; // advance the iterator 1 position
std::advance(first, 1); // advance the iterator 1 position
first = std::next(first); // returns iterator to the next element
std::advance(first, -1); // advance the iterator 1 position backwards
first = std::next(first, 20); // returns iterator to the element 20 position
```
forward
```CPP
first = std::prev(first, 5); // returns iterator to the element 5 position
```
backward
```CPP
auto dist = std::distance(my_vector.begin(), first); // returns distance between two iterators.
```
Note, second argument of std::distance should be reachable from the first one(or, in other words first should be
less or equal than second).
Even though you can perform arithmetic operators with iterators, not all operations are defined for all types of
iterators. a = b + 3; would work for Random Access Iterators, but wouldn't work for Forward or Bidirectional
Iterators, which still can be advanced by 3 position with something like b = a; ++b; ++b; ++b;. So it is
recommended to use special functions in case you are not sure what is iterator type (for example, in a template
function accepting iterator).
4. Iterator Concepts
The C++ standard describes several different iterator concepts. These are grouped according to how they behave in
the sequences they refer to. If you know the concept an iterator models (behaves like), you can be assured of the
behavior of that iterator regardless of the sequence to which it belongs. They are often described in order from the
most to least restrictive (because the next iterator concept is a step better than its predecessor):
Input Iterators : Can be dereferenced only once per position. Can only advance, and only one position at a
time.
Forward Iterators : An input iterator that can be dereferenced any number of times.
Bidirectional Iterators : A forward iterator that can also advance backwards one position at a time.
Random Access Iterators : A bidirectional iterator that can advance forwards or backwards any number of
positions at a time.
Contiguous Iterators (since C++17) : A random access iterator that guaranties that underlying data is
contiguous in memory.
Algorithms can vary depending on the concept modeled by the iterators they are given. For example, although
random_shuffle can be implemented for forward iterators, a more efficient variant that requires random access
iterators could be provided.

5. Iterator traits
Iterator traits provide uniform interface to the properties of iterators. They allow you to retrieve value, difference,
pointer, reference types and also category of iterator:
```CPP
template<class Iter>
Iter find(Iter first, Iter last, typename std::iterator_traits<Iter>::value_type val) {
while (first != last) {
if (*first == val)
return first;
++first;
}
return last;
}
```
Category of iterator can be used to specialize algorithms:
```CPP
template<class BidirIt>
void test(BidirIt a, std::bidirectional_iterator_tag) {
std::cout << "Bidirectional iterator is used" << std::endl;
}
template<class ForwIt>
void test(ForwIt a, std::forward_iterator_tag) {
std::cout << "Forward iterator is used" << std::endl;
}
template<class Iter>
void test(Iter a) {
test(a, typename std::iterator_traits<Iter>::iterator_category());
}
```
Categories of iterators are basically iterators concepts, except Contiguous Iterators don't have their own tag, since it
was found to break code.

## Section 4.2: Vector Iterator
begin returns an iterator to the first element in the sequence container.
end returns an iterator to the first element past the end.
If the vector object is const, both begin and end return a const_iterator. If you want a const_iterator to be
returned even if your vector is not const, you can use cbegin and cend.
Example:
```CPP
#include <vector>
#include <iostream>
int main() {
std::vector<int> v = { 1, 2, 3, 4, 5 }; //intialize vector using an initializer_list
for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
std::cout << *it << " ";
}
return 0;
}
```
Output:
    1 2 3 4 5


## Section 4.3: Map Iterator
An iterator to the first element in the container.
If a map object is const-qualified, the function returns a const_iterator. Otherwise, it returns an iterator.
```CPP
// Create a map and insert some values
std::map<char,int> mymap;
mymap['b'] = 100;
mymap['a'] = 200;
mymap['c'] = 300;
// Iterate over all tuples
for (std::map<char,int>::iterator it = mymap.begin(); it != mymap.end(); ++it)
std::cout << it->first << " => " << it->second << '\n';
```
Output:
    a => 200
    b => 100
    c => 300

## Section 4.4: Reverse Iterators
If we want to iterate backwards through a list or vector we can use a reverse_iterator. A reverse iterator is made
from a bidirectional, or random access iterator which it keeps as a member which can be accessed through base().
To iterate backwards use rbegin() and rend() as the iterators for the end of the collection, and the start of the
collection respectively.
For instance, to iterate backwards use:
```CPP
std::vector<int> v{1, 2, 3, 4, 5};
for (std::vector<int>::reverse_iterator it = v.rbegin(); it != v.rend(); ++it)
{
cout << *it;
} // prints 54321
```

A reverse iterator can be converted to a forward iterator via the base() member function. The relationship is that
the reverse iterator references one element past the base() iterator:
```CPP
std::vector<int>::reverse_iterator r = v.rbegin();
std::vector<int>::iterator i = r.base();
assert(&*r == &*(i-1)); // always true if r, (i-1) are dereferenceable
// and are not proxy iterators
```
```cpp
    +---+---+---+---+---+---+---+
    |   | 1 | 2 | 3 | 4 | 5 |   |
    +---+---+---+---+---+---+---+
     ?    ?               ?   ?
     |    |               |   |
   rend() |          rbegin() end()
          |                   rbegin().base()
       begin()
     rend().base()
```
In the visualization where iterators mark positions between elements, the relationship is simpler:
```cpp
    +---+---+---+---+---+
    | 1 | 2 | 3 | 4 | 5 |
    +---+---+---+---+---+
    ?                   ?
    |                   |
    |                  end()
    |                  rbegin()
    begin()            rbegin().base()
    rend()
    rend().base()
```

## Section 4.5: Stream Iterators
Stream iterators are useful when we need to read a sequence or print formatted data from a container:
```cpp
// Data stream. Any number of various whitespace characters will be OK.
std::istringstream istr("1\t 2 3 4");
std::vector<int> v;
// Constructing stream iterators and copying data from stream into vector.
std::copy(
// Iterator which will read stream data as integers.
std::istream_iterator<int>(istr),
// Default constructor produces end-of-stream iterator.
std::istream_iterator<int>(),
std::back_inserter(v));
// Print vector contents.
std::copy(v.begin(), v.end(),
//Will print values to standard output as integers delimeted by " -- ".
std::ostream_iterator<int>(std::cout, " -- "));
```
The example program will print 1 -- 2 -- 3 -- 4 -- to standard output.

## Section 4.6: C Iterators (Pointers)
```cpp
// This creates an array with 5 values.
const int array[] = { 1, 2, 3, 4, 5 };
#ifdef BEFORE_CPP11
// You can use `sizeof` to determine how many elements are in an array.
const int* first = array;
const int* afterLast = first + sizeof(array) / sizeof(array[0]);
// Then you can iterate over the array by incrementing a pointer until
// it reaches past the end of our array.
for (const int* i = first; i < afterLast; ++i) {
std::cout << *i << std::endl;
}
#else
// With C++11, you can let the STL compute the start and end iterators:
for (auto i = std::begin(array); i != std::end(array); ++i) {
std::cout << *i << std::endl;
}
#endif
```

This code would output the numbers 1 through 5, one on each line like this:
1
2
3
4
5
Breaking It Down
```cpp
const int array[] = { 1, 2, 3, 4, 5 };
```
This line creates a new integer array with 5 values. C arrays are just pointers to memory where each value is stored
together in a contiguous block.
```cpp
const int* first = array;
const int* afterLast = first + sizeof(array) / sizeof(array[0]);
```
These lines create two pointers. The first pointer is given the value of the array pointer, which is the address of the
first element in the array. The sizeof operator when used on a C array returns the size of the array in bytes.
Divided by the size of an element this gives the number of elements in the array. We can use this to find the
address of the block after the array.
```cpp
for (const int* i = first; i < afterLast; ++i) {
```
Here we create a pointer which we will use as an iterator. It is initialized with the address of the first element we
want to iterate over, and we'll continue to iterate as long as i is less than afterLast, which means as long as i is
pointing to an address within array.
```cpp
std::cout << *i << std::endl;
```
Finally, within the loop we can access the value our iterator i is pointing to by dereferencing it. Here the
dereference operator * returns the value at the address in i.


## Section 4.7: Write your own generator-backed iterator
A common pattern in other languages is having a function that produces a "stream" of objects, and being able to
use loop-code to loop over it.
We can model this in C++ as
```cpp
template<class T>
struct generator_iterator {
using difference_type=std::ptrdiff_t;
using value_type=T;
using pointer=T*;
using reference=T;
using iterator_category=std::input_iterator_tag;
std::optional<T> state;
std::function< std::optional<T>() > operation;
// we store the current element in "state" if we have one:
T operator*() const {
return *state;
}
// to advance, we invoke our operation. If it returns a nullopt
// we have reached the end:
generator_iterator& operator++() {
state = operation();
return *this;
}
generator_iterator operator++(int) {
auto r = *this;
C++ Notes for Professionals 39
++(*this);
return r;
}
// generator iterators are only equal if they are both in the "end" state:
friend bool operator==( generator_iterator const& lhs, generator_iterator const& rhs ) {
if (!lhs.state && !rhs.state) return true;
return false;
}
friend bool operator!=( generator_iterator const& lhs, generator_iterator const& rhs ) {
return !(lhs==rhs);
}
// We implicitly construct from a std::function with the right signature:
generator_iterator( std::function< std::optional<T>() > f ):operation(std::move(f))
{
if (operation)
state = operation();
}
// default all special member functions:
generator_iterator( generator_iterator && ) =default;
generator_iterator( generator_iterator const& ) =default;
generator_iterator& operator=( generator_iterator && ) =default;
generator_iterator& operator=( generator_iterator const& ) =default;
generator_iterator() =default;
};
```
live example.
We store the generated element early so we can more easily detect if we are already at the end.
As the function of an end generator iterator is never used, we can create a range of generator iterators by only
copying the std::function once. A default constructed generator iterator compares equal to itself, and to all other
end-generator-iterators.


# Chapter 5: Returning several values from a function
There are many situations where it is useful to return several values from a function: for example, if you want to
input an item and return the price and number in stock, this functionality could be useful. There are many ways to
do this in C++, and most involve the STL. However, if you wish to avoid the STL for some reason, there are still
several ways to do this, including structs/classes and arrays.
## Section 5.1: Using std::tuple
Version ≥ C++11
The type std::tuple can bundle any number of values, potentially including values of different types, into a single
return object:
```cpp
std::tuple<int, int, int, int> foo(int a, int b) { // or auto (C++14)
return std::make_tuple(a + b, a - b, a * b, a / b);
}
```
In C++17, a braced initializer list can be used:
Version ≥ C++17
```cpp
std::tuple<int, int, int, int> foo(int a, int b) {
return {a + b, a - b, a * b, a / b};
}
```
Retrieving values from the returned tuple can be cumbersome, requiring the use of the std::get template
function:
```cpp
auto mrvs = foo(5, 12);
auto add = std::get<0>(mrvs);
auto sub = std::get<1>(mrvs);
auto mul = std::get<2>(mrvs);
auto div = std::get<3>(mrvs);
```
If the types can be declared before the function returns, then std::tie can be employed to unpack a tuple into
existing variables:
```cpp
int add, sub, mul, div;
std::tie(add, sub, mul, div) = foo(5, 12);
```
If one of the returned values is not needed, std::ignore can be used:
```cpp
std::tie(add, sub, std::ignore, div) = foo(5, 12);
```
Version ≥ C++17
Structured bindings can be used to avoid std::tie:
```cpp
auto [add, sub, mul, div] = foo(5,12);
```
If you want to return a tuple of lvalue references instead of a tuple of values, use std::tie in place of
std::make_tuple.
```cpp
std::tuple<int&, int&> minmax( int& a, int& b ) {
if (b<a)
return std::tie(b,a);
else
return std::tie(a,b);
}
```
which permits
```cpp
void increase_least(int& a, int& b) {
std::get<0>(minmax(a,b))++;
}
```
In some rare cases you'll use std::forward_as_tuple instead of std::tie; be careful if you do so, as temporaries
may not last long enough to be consumed.

## Section 5.2: Structured Bindings
Version ≥ C++17
C++17 introduces structured bindings, which makes it even easier to deal with multiple return types, as you do not
need to rely upon std::tie() or do any manual tuple unpacking:
```cpp
std::map<std::string, int> m;
// insert an element into the map and check if insertion succeeded
auto [iterator, success] = m.insert({"Hello", 42});
if (success) {
// your code goes here
}
// iterate over all elements without having to use the cryptic 'first' and 'second' names
for (auto const& [key, value] : m) {
std::cout << "The value for " << key << " is " << value << '\n';
}
```cpp
Structured bindings can be used by default with std::pair, std::tuple, and any type whose non-static data
members are all either public direct members or members of an unambiguous base 
```cpp
class:
struct A { int x; };
struct B : A { int y; };
B foo();
// with structured bindings
const auto [x, y] = foo();
// equivalent code without structured bindings
const auto result = foo();
auto& x = result.x;
auto& y = result.y;
```
If you make your type "tuple-like" it will also automatically work with your type. A tuple-like is a type with
appropriate tuple_size, tuple_element and get written:
```cpp
namespace my_ns {
struct my_type {
int x;
double d;
std::string s;
};
struct my_type_view {
my_type* ptr;
};
}
namespace std {
template<>
struct tuple_size<my_ns::my_type_view> : std::integral_constant<std::size_t, 3>
{};
template<> struct tuple_element<my_ns::my_type_view, 0>{ using type = int; };
template<> struct tuple_element<my_ns::my_type_view, 1>{ using type = double; };
template<> struct tuple_element<my_ns::my_type_view, 2>{ using type = std::string; };
}
namespace my_ns {
template<std::size_t I>
decltype(auto) get(my_type_view const& v) {
if constexpr (I == 0)
return v.ptr->x;
else if constexpr (I == 1)
return v.ptr->d;
else if constexpr (I == 2)
return v.ptr->s;
static_assert(I < 3, "Only 3 elements");
}
}
now this works:
my_ns::my_type t{1, 3.14, "hello world"};
my_ns::my_type_view foo() {
return {&t};
}
int main() {
auto[x, d, s] = foo();
std::cout << x << ',' << d << ',' << s << '\n';
}
```

## Section 5.3: Using struct
A struct can be used to bundle multiple return values:
Version ≥ C++11
```cpp
struct foo_return_type {
int add;
int sub;
int mul;
int div;
};
foo_return_type foo(int a, int b) {
return {a + b, a - b, a * b, a / b};
}
auto calc = foo(5, 12);
```
Version < C++11
Instead of assignment to individual fields, a constructor can be used to simplify the constructing of returned values:
```cpp
struct foo_return_type {
int add;
int sub;
int mul;
int div;
foo_return_type(int add, int sub, int mul, int div)
: add(add), sub(sub), mul(mul), div(div) {}
};
foo_return_type foo(int a, int b) {
return foo_return_type(a + b, a - b, a * b, a / b);
}
foo_return_type calc = foo(5, 12);
```
The individual results returned by the function foo() can be retrieved by accessing the member variables of the
struct calc:
```cpp
std::cout << calc.add << ' ' << calc.sub << ' ' << calc.mul << ' ' << calc.div << '\n';
```
Output:
    17 -7 60 0
Note: When using a struct, the returned values are grouped together in a single object and accessible using
meaningful names. This also helps to reduce the number of extraneous variables created in the scope of the
returned values.
Version ≥ C++17
In order to unpack a struct returned from a function, structured bindings can be used. This places the outparameters
on an even footing with the in-parameters:
```cpp
int a=5, b=12;
auto[add, sub, mul, div] = foo(a, b);
std::cout << add << ' ' << sub << ' ' << mul << ' ' << div << '\n';
```
The output of this code is identical to that above. The struct is still used to return the values from the function.
This permits you do deal with the fields individually.

## Section 5.4: Using Output Parameters
Parameters can be used for returning one or more values; those parameters are required to be non-const pointers
or references.
1. References:
```cpp
void calculate(int a, int b, int& c, int& d, int& e, int& f) {
c = a + b;
d = a - b;
C++ Notes for Professionals 44
e = a * b;
f = a / b;
}
```
2. Pointers:
```cpp
void calculate(int a, int b, int* c, int* d, int* e, int* f) {
*c = a + b;
*d = a - b;
*e = a * b;
*f = a / b;
}
```
Some libraries or frameworks use an empty 'OUT' #define to make it abundantly obvious which parameters are
output parameters in the function signature. This has no functional impact, and will be compiled out, but makes the
function signature a bit clearer;
```cpp
#define OUT
void calculate(int a, int b, OUT int& c) {
c = a + b;
}
```

## Section 5.5: Using a Function Object Consumer
We can provide a consumer that will be called with the multiple relevant values:
Version ≥ C++11
```cpp
template <class F>
void foo(int a, int b, F consumer) {
consumer(a + b, a - b, a * b, a / b);
}
// use is simple... ignoring some results is possible as well
foo(5, 12, [](int sum, int , int , int ){
std::cout << "sum is " << sum << '\n';
});
```
This is known as "continuation passing style".
You can adapt a function returning a tuple into a continuation passing style function via:
Version ≥ C++17
```cpp
template<class Tuple>
struct continuation {
Tuple t;
template<class F>
decltype(auto) operator->*(F&& f)&&{
return std::apply( std::forward<F>(f), std::move(t) );
}
};
std::tuple<int,int,int,int> foo(int a, int b);
continuation(foo(5,12))->*[](int sum, auto&&...) {
std::cout << "sum is " << sum << '\n';
};
```
with more complex versions being writable in C++14 or C++11.


## Section 5.6: Using std::pair
The struct template std::pair can bundle together exactly two return values, of any two types:
```cpp
#include <utility>
std::pair<int, int> foo(int a, int b) {
return std::make_pair(a+b, a-b);
}
```
With C++11 or later, an initializer list can be used instead of std::make_pair:
Version ≥ C++11
```cpp
#include <utility>
std::pair<int, int> foo(int a, int b) {
return {a+b, a-b};
}
```
The individual values of the returned std::pair can be retrieved by using the pair's first and second member
objects:
```cpp
std::pair<int, int> mrvs = foo(5, 12);
std::cout << mrvs.first + mrvs.second << std::endl;
```
Output:
10

## Section 5.7: Using std::array
Version ≥ C++11
The container std::array can bundle together a fixed number of return values. This number has to be known at
compile-time and all return values have to be of the same type:
```cpp
std::array<int, 4> bar(int a, int b) {
return { a + b, a - b, a * b, a / b };
}
```
This replaces c style arrays of the form int bar[4]. The advantage being that various c++ std functions can now be
used on it. It also provides useful member functions like at which is a safe member access function with bound
checking, and size which allows you to return the size of the array without calculation.

## Section 5.8: Using Output Iterator
Several values of the same type can be returned by passing an output iterator to the function. This is particularly
common for generic functions (like the algorithms of the standard library).
Example:
```cpp
template<typename Incrementable, typename OutputIterator>
void generate_sequence(Incrementable from, Incrementable to, OutputIterator output) {
for (Incrementable k = from; k != to; ++k)
*output++ = k;
}
```
Example usage:
```cpp
std::vector<int> digits;
generate_sequence(0, 10, std::back_inserter(digits));
// digits now contains {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```

## Section 5.9: Using std::vector
A std::vector can be useful for returning a dynamic number of variables of the same type. The following example
uses int as data type, but a std::vector can hold any type that is trivially copyable:
```cpp
#include <vector>
#include <iostream>
// the following function returns all integers between and including 'a' and 'b' in a vector
// (the function can return up to std::vector::max_size elements with the vector, given that
// the system's main memory can hold that many items)
std::vector<int> fillVectorFrom(int a, int b) {
std::vector<int> temp;
for (int i = a; i <= b; i++) {
temp.push_back(i);
}
return temp;
}
int main() {
// assigns the filled vector created inside the function to the new vector 'v'
std::vector<int> v = fillVectorFrom(1, 10);
// prints "1 2 3 4 5 6 7 8 9 10 "
for (int i = 0; i < v.size(); i++) {
std::cout << v[i] << " ";
}
std::cout << std::endl;
return 0;
}
```